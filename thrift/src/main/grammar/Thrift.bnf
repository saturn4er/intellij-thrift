{
    parserClass="com.intellij.plugins.thrift.lang.parser.ThriftParser"
    parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"
    psiImplUtilClass="com.intellij.plugins.thrift.util.ThriftPsiUtil"

    implements="com.intellij.plugins.thrift.lang.psi.ThriftPsiCompositeElement"
    extends="com.intellij.plugins.thrift.lang.psi.impl.ThriftPsiCompositeElementImpl"

    psiClassPrefix="Thrift"
    psiImplClassSuffix="Impl"
    psiPackage="com.intellij.plugins.thrift.lang.psi"
    psiImplPackage="com.intellij.plugins.thrift.lang.psi.impl"

    elementTypeHolderClass="com.intellij.plugins.thrift.lang.lexer.ThriftTokenTypes"
    elementTypeClass="com.intellij.plugins.thrift.lang.lexer.ThriftElementType"
    tokenTypeClass="com.intellij.plugins.thrift.lang.lexer.ThriftElementType"

    tokens=[
        space               = 'regexp:\s+'
        COMMENT             = 'regexp://.*'


        BLOCK_COMMENT       = "regexp:/\* !([^]* \*/[^]*) (\*/)?"
        FLOAT_NUMBER        = 'regexp:[+-]?\d+(\.\d*)(e[+-]?\d+)?'
        INT_NUMBER          = 'regexp:[+-]?\d+'
        HEX_NUMBER         = 'regexp:[+-]?0x[0-9a-fA-F]+'

        LEFT_CURLY_BRACE    = '{'
        RIGHT_CURLY_BRACE   = '}'
        LEFT_BRACKET        = '['
        RIGHT_BRACKET       = ']'
        LEFT_BRACE          = '('
        RIGHT_BRACE         = ')'
        EQUALS              = '='
        SemiColon           = ';'
        Colon               = ':'
        LT                  = '<'
        GT                  = '>'
        COMMA               = ','
        Plus                = '+'
        Minus               = '-'
        MULTIPLY            = '*'
// types
        MAP                 = 'map'
        SET                 = 'set'
        LIST                = 'list'
        CPP_TYPE            = 'cpp_type'
        BOOL                = 'bool'
        BYTE                = 'byte'
        I8                  = 'i8'
        I16                 = 'i16'
        I32                 = 'i32'
        I64                 = 'i64'
        DOUBLE              = 'double'
        STRING              = 'string'
        BINARY              = 'binary'
        SLIST               = 'slist'

// header
        INCLUDE             = 'include'
        CPP_INCLUDE         = 'cpp_include'

        NAMESPACE           = 'namespace'
        XSD_NAMESPACE       = 'xsd_namespace'
        PHP_NAMESPACE       = 'php_namespace'

// definitions
        ENUM                = 'enum'
        SENUM               = 'senum'
        SERVICE             = 'service'
        EXTENDS             = 'extends'
        EXCEPTION           = 'exception'
        STRUCT              = 'struct'
        TYPEDEF             = 'typedef'
        UNION               = 'union'
        CONST               = 'const'
        XSD_ALL             = 'xsd_all'

// method
        VOID                = 'void'
        THROWS              = 'throws'
        ONEWAY              = 'oneway'

// field
        REQUIRED            = 'required'
        OPTIONAL            = 'optional'
        XSD_OPTIONAL        = 'xsd_optional'
        XSD_NILLABLE        = 'xsd_nillable'
        XSD_ATTRS           = 'xsd_attrs'

// other
        LITERAL             = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
        IDENTIFIER          = 'regexp:[\p{Alpha}_][\p{Alnum}._-]*'
    ];

    pin(".*_declaration") = 1
    mixin(".*_declaration") = "com.intellij.plugins.thrift.lang.psi.impl.ThriftTopLevelDeclarationImpl"
    implements(".*_declaration") = "com.intellij.plugins.thrift.lang.psi.ThriftTopLevelDeclaration"
}

document ::=  top_level_element*
private top_level_element ::=  statement | declaration {recoverWhile=top_level_recover}

private top_level_recover ::= !('const' | 'cpp_include' | 'enum' | 'exception' | 'include' | 'namespace' |
                              'php_namespace' | 'senum' | 'service' | 'struct' | 'typedef' | 'union' |
                              'xsd_namespace' )


private statement ::= include_statement
    | namespace_statement

include_statement ::=  ('include' | 'cpp_include') LITERAL {
  pin=1
  methods=[
    getReferences
    getPath
  ]
}

namespace_statement ::=  std_namespace | php_namespace | xsd_namespace
private xsd_namespace ::= 'xsd_namespace' LITERAL {pin=1}
private php_namespace ::= 'php_namespace' LITERAL {pin=1}
private std_namespace ::= 'namespace' (namespace_scope (IDENTIFIER | LITERAL)) {pin=1}

namespace_scope  ::=  MULTIPLY | IDENTIFIER

definition_name ::= IDENTIFIER
{
    implements=[
        "com.intellij.psi.PsiNamedElement"
        "com.intellij.navigation.NavigationItem"
        "com.intellij.psi.PsiNameIdentifierOwner"
    ]
    methods=[
      setName
      getName
      getNameIdentifier
    ]
}

private declaration ::=  const_declaration
    | type_declaration
    | enum_declaration
    | senum_declaration
    | struct_declaration
    | union_declaration
    | exception_declaration
    | service_declaration

const_declaration   ::=  'const' annotated_type definition_name '=' const_value list_separator?
type_declaration    ::=  'typedef' annotated_type definition_name type_annotations?

enum_declaration    ::=  'enum' definition_name '{' enum_body? '}' type_annotations?
private enum_body   ::= enum_field ( list_separator? enum_field )*
enum_field ::= IDENTIFIER ('=' int_constant)? type_annotations? {pin=1 recoverWhile=enum_field_recovery}
private enum_field_recovery ::= !('}' | IDENTIFIER | ',' )

senum_declaration           ::=  'senum' definition_name '{' senum_body? '}' type_annotations?
private senum_body ::= senum_field (list_separator? senum_field)*  {
    pin=1
    recoverWhile=senum_field_recovery
    mixin="com.intellij.plugins.thrift.lang.psi.impl.SenumBodyImpl"
}
senum_field ::= LITERAL

private senum_field_recovery ::= !('}' | LITERAL)

struct_declaration          ::=  'struct' definition_name 'xsd_all'? '{' fields_body '}' type_annotations?
union_declaration           ::=  'union' definition_name 'xsd_all'? '{' fields_body '}' type_annotations?
exception_declaration       ::=  'exception' definition_name '{' fields_body '}' type_annotations?
private fields_body         ::= fields_with_curly_brace_recovery
service_declaration         ::=  'service' definition_name ( 'extends' service_super_name )? '{' service_body '}' type_annotations?

service_super_name ::= custom_type
private service_body ::= (function list_separator?)*
{
    recoverWhile=curly_brace_recovery
    implements="com.intellij.plugins.thrift.lang.psi.ThriftDeclarationBody"}

private fields ::= field*
private fields_with_brace_recovery ::= fields {recoverWhile=brace_recovery}
private fields_with_curly_brace_recovery ::= fields {recoverWhile=curly_brace_recovery}
field           ::= field_id? field_req? annotated_type definition_name ('=' const_value)? field_xsd_options? type_annotations? list_separator?
{
  pin=3
  recoverWhile=field_recovery
  mixin="com.intellij.plugins.thrift.lang.psi.impl.AbstractThriftDeclaration"
  implements="com.intellij.plugins.thrift.lang.psi.ThriftSubDeclaration"
}
field_id         ::=  int_constant ':'
field_req        ::=  'required' | 'optional'
private field_recovery ::= !(')' | '+' | '-' | 'binary' | 'bool' | 'byte' | 'double' | 'i8' | 'i16' | 'i32' | 'i64' | 'list' |
                            'map' | 'optional' | 'required' | 'set' | 'slist' | 'string' | '}'| int_constant | IDENTIFIER  | ';' | ',' )

private field_xsd_options ::=  'xsd_optional'? 'xsd_nillable'? field_xdf_attrs?
field_xdf_attrs        ::=  'xsd_attrs' '{' fields '}' {pin=1}

function        ::=  'oneway'? function_type definition_name '(' fields_with_brace_recovery ')' function_throws? type_annotations?
{
  pin=2 recoverWhile=function_recovery
  mixin="com.intellij.plugins.thrift.lang.psi.impl.AbstractThriftDeclaration"
  implements="com.intellij.plugins.thrift.lang.psi.ThriftSubDeclaration"
}
private function_recovery ::= !('binary' | 'bool' | 'byte' | 'double' |'i8' | 'i16' | 'i32' | 'i64' | 'list' | 'map' |
                               'oneway' | 'set' | 'slist' | 'string' | 'void' | '}' | IDENTIFIER | list_separator)
function_type       ::=  'void' | annotated_type
function_throws     ::=  'throws' '(' fields_with_brace_recovery ')' {pin=1}

annotated_type ::= type type_annotations?
type           ::= base_type | container_type | custom_type

base_type       ::=  ('bool' | 'byte' | 'i8' | 'i16' | 'i32' | 'i64' | 'double' | 'string' | 'binary' | 'slist')  {extends=type}
container_type  ::=  (map_type | set_type | list_type)  {extends=type}
map_type        ::=  'map' cpp_type_attr? '<' annotated_type ',' annotated_type '>'
{
    pin=1
    extends=container_type
    methods=[
        keyType="/type[0]"
        valueType="/type[1]"
  ]
}

set_type            ::=  'set' cpp_type_attr? '<' annotated_type '>' {pin=1 extends=container_type}
list_type           ::=  'list' '<' annotated_type '>' cpp_type_attr? {pin=1 extends=container_type}
cpp_type_attr       ::=  'cpp_type' LITERAL {pin=1}

custom_type         ::= IDENTIFIER {
  methods=[
    getReferences
  ]
  extends=type
}

const_value      ::=  int_constant | double_constant | LITERAL | IDENTIFIER | const_list | const_map
int_constant     ::=  (INT_NUMBER | HEX_NUMBER)
double_constant  ::=  (FLOAT_NUMBER)
const_list       ::=  '[' (const_value list_separator?)* ']'
const_map        ::=  '{' const_map_item* '}'
const_map_item   ::=  const_value ':' const_value list_separator?

list_separator   ::=  ',' | ';'

type_annotations ::= '(' (type_annotation list_separator?)* ')' {pin=1}
type_annotation ::= IDENTIFIER ('=' LITERAL)? {pin=1 recoverWhile=type_annotation_recovery}
type_annotation_recovery ::= !(list_separator | ')')

private brace_recovery ::= !(')')
private curly_brace_recovery ::= !('}')